Description: Add support for attributewhitelist
 The handling is similar to how the standard blacklist and whitelist are
 handled except we have to recursively check array contents.
 See also  www/fetch.php and hooks/hook_cron.php
Author: Mischa Sall√© <msalle@nikhef.nl>
Author: Tamas Balogh <tamasb@nikhef.nl>
--- a/modules/metarefresh/lib/MetaLoader.php	2019-10-04 23:12:31.000000000 +0200
+++ b/modules/metarefresh/lib/MetaLoader.php	2019-11-21 21:43:08.977859355 +0100
@@ -159,6 +159,25 @@
                 }
             }
 
+            /* Do we have an attribute whitelist? */
+            if (isset($source['attributewhitelist']) && !empty($source['attributewhitelist'])) {
+                $idpmetadata = $entity->getMetadata20IdP();
+                if (!isset($idpmetadata)) /* Skip non-IdPs */
+                    continue;
+
+                /* Do a recursive comparison for each whitelist of the attributewhitelist with the idpmetadata for this IdP. At least one of these whitelists should match */
+                $match=0;
+                foreach ($source['attributewhitelist'] as $whitelist)   {
+                    if ($this->containsArray($whitelist, $idpmetadata)) {
+                        $match=1;
+                        break;
+                    }
+                }
+                if ($match==0) /* No match found -> next IdP */
+                    continue;
+                Logger::debug('Whitelisted entityID: '. $entity->getEntityID());
+            }
+
             if (array_key_exists('certificates', $source) && $source['certificates'] !== null) {
                 if (!$entity->validateSignature($source['certificates'])) {
                     Logger::info(
@@ -218,6 +237,63 @@
     }
 
 
+    /*
+     * Recursively checks whether array $dst contains array $src. If $src
+     * is not an array, a literal comparison is being performed.
+     */
+    private function containsArray($src, $dst) {
+        if (is_array($src)) {
+            if (!is_array($dst))    {
+                return false;
+            }
+            $dstkeys=array_keys($dst);
+
+            /* Loop over all src keys */
+            foreach($src as $srckey => $srcval)    {
+                if (is_int($srckey))    {
+                    /* key is number, check that the key appears as one
+                     * of the destination keys: if not, then src has
+                     * more keys than dst */
+                    if (!array_key_exists($srckey, $dst))
+                        return false;
+
+                    /* loop over dest keys, to find value: we don't know
+                     * whether they are in the same order */
+                    $submatch=0;
+                    foreach ($dstkeys as $dstkey)   {
+                        if ($this->containsArray($srcval, $dst[$dstkey])) {
+                            $submatch=1;
+                            break;
+                        }
+                    }
+                    if ($submatch == 0)
+                        return false;
+                } else {
+                    /* key is regexp: find matching keys */
+                    $matchingdstkeys=preg_grep($srckey, $dstkeys);
+                    if (!is_array($matchingdstkeys))
+                        return false;
+
+                    $match=0;
+                    foreach ($matchingdstkeys as $dstkey) {
+                        if ($this->containsArray($srcval, $dst[$dstkey])) {
+                            /* Found a match */
+                            $match=1;
+                            break;
+                        }
+                    }
+                    if ($match==0) /* none of the keys has a matching value */
+                        return false;
+                }
+            }
+            /* each src key/value matches */
+            return true;
+        } else {
+            /* src is not an array, do a regexp match against dst */
+            return (preg_match($src, $dst) === 1);
+        }
+    }
+
     /**
      * Create HTTP context, with any available caches taken into account
      *
